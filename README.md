# <<数据结构与算法之美>> 阶段学习记录
### 第一阶段
#### 1.复杂度分析（M，10分）
  - [复杂度分析（上）：如何分析算法的执行效率和资源消耗](https://time.geekbang.org/column/article/40036)
  - [复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度](https://time.geekbang.org/column/article/40447)
  > `大O时间复杂度表示法：表示代码执行时间随着数据规模增长的变化趋势，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)`;空间复杂度表示算法的存储空间与数据规模之间的增长关系，常见的有O(1)、O(n)、O(n2 );最好时间复杂度、最坏时间复杂度、平均时间复杂度(考虑概率论的知识)、均摊时间复杂度

#### 2.数组、栈、队列（E，8分）
##### 2.1 数组
  - [数组：为什么很多编程语言中数组都从0开始编号？](https://time.geekbang.org/column/article/40961)
  > 数组和链表的区别：链表适合插入、删除，时间复杂度O(1)，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)；数组为何从0开始编号而不是从1开始编号，从数组存储的内存模型上看，“下标”最确切的定义是“偏移（offset）”，如果从0开始计算公式为 a[k]_address = base_address + k * type_size，如果从1开始计算，内存地址公式变为 a[k]_address = base_address + k * type_size,cpu多了一次减法的指令。
##### 2.2 栈
  - [栈：如何实现浏览器的前进和后退功能？](https://time.geekbang.org/column/article/41222)
  > 栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是最大特点。栈既可以用数组实现，也可以链表实现，不管基于数组还是链表，入栈、出栈的时间复杂度都为O(1)，可以支持动态扩容的顺序栈，需要重点掌握它的均摊时间复杂度分析方法。
  `为什么函数调用用栈来保存临时变量呢？其他数据结构不行吗？其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。`
##### 2.3 队列
  - [队列：队列在线程池等有限资源池中的应用](https://time.geekbang.org/column/article/41330)
  > 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。允许插入的一端为队尾，允许删除的一端为堆对头。队列不允许在中间部位进行操作。队列这种数据结构很基础，平时的业务开发不大可能从零开始实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。**阻塞队列**就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列满了，那么插入数据的操作会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。线程安全的队列叫做**并发队列**，最简单直接的实现方式直接在enqueue()、dequeue()方式上加锁，但是锁力度大并发度会比较低，同一时刻仅允许一个存或者取取操作。
  
#### 3.链表（M，9分）
  - [链表（上）：如何实现LRU缓存淘汰算法?](https://time.geekbang.org/column/article/41013)
  > 数组需要一块连续的内存空间来存储，链表通过“指针”将一组零散的内存块串联起来使用。常见的链表结构：单链表、双链表、循环链表。循环链表的优点是从链尾到链头比较方便，当处理的数据具有环型结构特点时，特别适合采用环型链表，比如约瑟夫问题。分析数组与链表的时间复杂度和空间复杂度。数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。
  - 如何基于链表实现LRU缓存淘汰算法？
    - 我们维护一个有序单链表，越靠近尾部的结点是越早之前访问的，当有一个新的数据被访问时，我们从链表头开始顺序遍历链表
    - 1.如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
    - 2.如果此数据没有在缓存链表中，又可以分为两种情况：一 如果此时缓存未满，则将此节点直接插入到链表的头部；二 如果此时缓存已满，则链表尾结点删除，将新的数据插入链表的头部。
  - [链表（下）：如何轻松写出正确的链表代码？](https://time.geekbang.org/column/article/41149)
  > 几个写链表代码技巧：一 理解指针或引用的含义 二 警惕指针丢失和内存泄漏 三 利用哨兵简化实现难度 四 重点留意边界条件处理 五 举例画图，辅助思考 六 多写多练，没有捷径
  - 经常用来检查链表代码是否正确的边界条件有这几个：
  - 如果链表为空时，代码是否能正常工作？
  - 如果链表只包含一个节点时，代码是否能正常工作？
  - 如果链表只包含两个节点时，代码是否能正常工作？
  - 代码逻辑在处理头节点和尾结点的时候，是否能正常工作？



#### 4.递归（H，10分）
  - [递归：如何用三行代码找到“最终推荐人”？](https://time.geekbang.org/column/article/41440)
  > 递归需要满足的三个条件：1.一个问题的解可以分解为几个子问题的解 2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样 3.存在递归终止条件。写递归代码最关键的是写出递推公式，找到终止条件。总结：**写递归代码的关键就是找到如何将最大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。**
  - [递归树：如何借助树来求解递归算法的时间复杂度？](https://time.geekbang.org/column/article/69388)
  > **借助递归树来分析递归算法的时间复杂度。**

#### 5.排序、二分查找（E，7分）
##### 5.1 冒泡排序、插入排序、选择排序
  - [排序（上）：为什么插入排序比冒泡排序更受欢迎？](https://time.geekbang.org/column/article/41802)
##### 5.2 归并排序、快速排序
  - [排序（下）：如何用快排思想在O(n)内查找第K大元素？](https://time.geekbang.org/column/article/41913)
##### 5.3 桶排序、计数排序、基数排序
  - [线性排序：如何根据年龄给100万用户数据排序？](https://time.geekbang.org/column/article/42038)
##### 5.4 排序优化
  - [排序优化：如何实现一个通用的、高性能的排序函数？](https://time.geekbang.org/column/article/42359)
##### 5.5 二分查找
  - [二分查找（上）：如何用最省内存的方式实现快速查找功能？](https://time.geekbang.org/column/article/42520)

### 第二阶段
#### 1.散列表（M，8分）
  - [散列表（上）：Word文档中的单词拼写检查功能是如何实现的？](https://github.com/iostalks/Algorithms/blob/master/64233)
  - [散列表（中）：如何打造一个工业级水平的散列表？](https://time.geekbang.org/column/article/64586)
  - [散列表（下）：为什么散列表和链表经常会一起使用？](https://time.geekbang.org/column/article/64858)
#### 2.二叉树（M，9分）
##### 2.1 二叉树基础
  - [二叉树基础（上）：什么样的二叉树适合用数组来存储？](https://time.geekbang.org/column/article/67856)
  - [二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？](https://time.geekbang.org/column/article/68334)
##### 2.2 平衡二叉树
  - [红黑树（上）：为什么工程中都用红黑树这种二叉树？](https://time.geekbang.org/column/article/68638)
  - [红黑树（下）：掌握这些技巧，你也可以实现一个红黑树](https://time.geekbang.org/column/article/68976)
  - 
#### 3.堆和堆排序（M，9分）
  - [堆和堆排序：为什么说堆排序没有快速排序快？](https://time.geekbang.org/column/article/69913)
  - [堆的应用：如何快速获取到Top 10最热门的搜索关键词？](https://time.geekbang.org/column/article/70187)
#### 4.BF/RK字符串匹配算法（E，7分）
  - [字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？](https://time.geekbang.org/column/article/71187)
#### 5.Trie树（M，7分）
  - [Trie树：如何实现搜索引擎的搜索关键词提示功能？](https://time.geekbang.org/column/article/72414)
#### 6.图的表示（E，8分）
##### 6.1 无向图、有向图、带权图
  - [图的表示：如何存储微博、微信等社交网络中的好友关系？](https://time.geekbang.org/column/article/70537)
#### 7.深度、广度优先搜索（H，8分）
  - [深度和广度优先搜索：如何找出社交网络中的三度好友关系？](https://time.geekbang.org/column/article/70891)

### 第三阶段


### 第四阶段
